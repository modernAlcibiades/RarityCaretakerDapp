{"version":3,"sources":["components/NoWalletDetected.js","components/NetworkErrorMessage.js","components/ConnectWallet.js","components/ApproveForAll.js","components/TransactionErrorMessage.js","components/WaitingForTransactionMessage.js","components/Dapp.js","index.js"],"names":["NoWalletDetected","className","href","target","rel","NetworkErrorMessage","message","dismiss","role","type","data-dismiss","aria-label","onClick","aria-hidden","ConnectWallet","connectWallet","networkError","ApproveForAll","approveCaretaker","doDaily","tokenIds","address","style","display","margin","listItems","map","id","for","name","value","defaultChecked","onSubmit","event","preventDefault","caller","srcElement","console","log","Object","keys","caretaker","FormData","get","checkboxes","document","querySelectorAll","approveTokens","forEach","checkbox","push","required","default","TransactionErrorMessage","substring","WaitingForTransactionMessage","txHash","axios","require","Dapp","props","initialState","selectedAddress","undefined","balance","rarity_address","caretaker_address","FTMSCAN_API_KEY","summoners","approved","txBeingSent","transactionError","state","this","isMetaMaskInstalled","toString","_getRpcErrorMessage","_dismissTransactionError","tokens","_approveCaretaker","_doDaily","_connectWallet","_dismissNetworkError","ethereum","window","Boolean","isMetaMask","_stopPollingData","request","method","_checkNetwork","_initialize","error","on","newAddress","_resetState","userAddress","setState","_initializeEthers","_getSummoners","_startPollingData","_provider","ethers","providers","Web3Provider","_rarity","Contract","Rarity","abi","getSigner","_caretaker","Caretaker","_pollDataInterval","setInterval","_getBalance","clearInterval","contract","apikey","url","response","data","startsWith","result","a","tokenID","utils","getBalance","formatEther","addr","getApproved","approve","txn","hash","wait","status","Error","code","_approval","timenow","Math","floor","Date","now","adventurers_log","_get_ready_for_adventure","checked_tokens","i","length","val","doAll","txn3","receipt3","events","networkVersion","React","Component","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.21f24ff1.chunk.js","sourcesContent":["import React from \"react\";\n\nexport function NoWalletDetected() {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-6 p-4 text-center\">\n          <p>\n            No Ethereum wallet was detected. <br />\n            Please install{\" \"}\n            <a\n              href=\"http://metamask.io\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              MetaMask\n            </a>\n            .\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NetworkErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      {message}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport { NetworkErrorMessage } from \"./NetworkErrorMessage\";\n\nexport function ConnectWallet({ connectWallet, networkError, dismiss }) {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-12 text-center\">\n          {/* Metamask network should be set to Localhost:8545. */}\n          {networkError && (\n            <NetworkErrorMessage \n              message={networkError} \n              dismiss={dismiss} \n            />\n          )}\n        </div>\n        <div className=\"col-6 p-4 text-center\">\n          <p>Please connect to your wallet.</p>\n          <button\n            className=\"btn btn-warning\"\n            type=\"button\"\n            onClick={connectWallet}\n          >\n            Connect Wallet\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function ApproveForAll({ approveCaretaker, doDaily, tokenIds, address }) {\n  const style = {\n    display: \"block\",\n    margin: \"10px 0 0\",\n  }\n  const listItems = tokenIds.map((id) =>\n    <label for={id} style={style}><input type=\"checkbox\" name=\"tokenId\" value={id} id={id} defaultChecked=\"true\" /> {id}</label >);\n  return (\n    <div>\n      <h4>ApproveForAll</h4>\n      <form\n        onSubmit={(event) => {\n          // This function just calls the transferTokens callback with the\n          // form's data.\n          event.preventDefault();\n          let caller = event.srcElement;\n          console.log(\"Caller\", caller);\n          console.log(Object(event).keys);\n\n          const formData = new FormData(event.target);\n          const caretaker = formData.get(\"caretaker\");\n\n          const checkboxes = document.querySelectorAll('input[name=\"tokenId\"]:checked');\n          let approveTokens = [];\n          checkboxes.forEach((checkbox) => {\n            console.log(Object.keys(checkbox));\n            approveTokens.push(checkbox.value);\n          });\n          console.log(approveTokens);\n\n          if (caretaker) {\n            approveCaretaker(caretaker, approveTokens);\n          }\n        }}\n      >\n        <div className=\"form-group\">\n          <label>Token IDs</label>\n          <ul>{listItems}</ul>\n        </div>\n        <div className=\"form-group\">\n          <label>Approve caretaker for all</label>\n          <input className=\"form-control\" type=\"text\" name=\"caretaker\" value={address} required />\n        </div>\n        <div className=\"form-group\">\n          <input className=\"btn btn-primary\" type=\"submit\" name=\"approve\" value=\"Approve Caretaker\" default />\n        </div>\n        <div className=\"form-group\">\n          <input className=\"btn btn-primary\" type=\"button\" name=\"dodaily\" value=\"Do Daily\"\n            onClick={(event) => {\n              const checkboxes = document.querySelectorAll('input[name=\"tokenId\"]:checked');\n              let approveTokens = [];\n              checkboxes.forEach((checkbox) => {\n                console.log(Object.keys(checkbox));\n                approveTokens.push(checkbox.value);\n              });\n              doDaily(approveTokens);\n            }\n            } />\n        </div>\n      </form>\n\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function TransactionErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      Error sending transaction: {message.substring(0, 100)}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function WaitingForTransactionMessage({ txHash }) {\n  return (\n    <div className=\"alert alert-info\" role=\"alert\">\n      Waiting for transaction <strong>{txHash}</strong> to be mined\n    </div>\n  );\n}\n","import React from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers } from \"ethers\";\n\n// We import the contract's artifacts and address here, as we are going to be\n// using them with ethers\nimport Caretaker from \"../contract_json/RarityCaretaker.json\";\nimport Rarity from \"../contract_json/rarity.json\";\n\n\n// All the logic of this dapp is contained in the Dapp component.\n// These other components are just presentational ones: they don't have any\n// logic. They just render HTML.\nimport { NoWalletDetected } from \"./NoWalletDetected\";\nimport { ConnectWallet } from \"./ConnectWallet\";\nimport { ApproveForAll } from \"./ApproveForAll\";\nimport { TransactionErrorMessage } from \"./TransactionErrorMessage\";\nimport { WaitingForTransactionMessage } from \"./WaitingForTransactionMessage\";\nimport { NoTokensMessage } from \"./NoTokensMessage\";\n\n// This is the Hardhat Network id, you might change it in the hardhat.config.js\n// Here's a list of network ids https://docs.metamask.io/guide/ethereum-provider.html#properties\n// to use when deploying to other networks.\n\nconst axios = require('axios');\n\n// This is an error code that indicates that the user canceled a transaction\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\nconst FTMSCAN_API = \"https://api.ftmscan.com/api\";\n\n// Dapp Status Section\n\n// This component is in charge of doing these things:\n//   1. It connects to the user's wallet\n//   2. Initializes ethers and the Token contract\n//   3. Polls the user balance to keep it updated.\n//   4. Transfers tokens by sending transactions\n//   5. Renders the whole application\n//\n// Note that (3) and (4) are specific of this sample application, but they show\n// you how to keep your Dapp and contract's state in sync,  and how to send a\n// transaction.\nexport class Dapp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // We store multiple things in Dapp's state.\n    // You don't need to follow this pattern, but it's an useful example.\n    this.initialState = {\n      // The user's address and balance\n      selectedAddress: undefined,\n      balance: 0,\n      // network configuration\n      rarity_address: \"0xce761D788DF608BD21bdd59d6f4B54b2e27F25Bb\",\n      caretaker_address: \"0x9217727cbd2d3017FE83601006e8Be1fa8D6282F\",\n      FTMSCAN_API_KEY: undefined,\n\n      // rarity related stuff\n      summoners: [],\n      approved: [],\n      // The ID about transactions being sent, and any possible error with them\n      txBeingSent: undefined,\n      transactionError: undefined,\n      networkError: undefined,\n    };\n    this.state = this.initialState;\n  }\n\n  render() {\n    // Ethereum wallets inject the window.ethereum object. If it hasn't been\n    // injected, we instruct the user to install MetaMask.\n    if (!this.isMetaMaskInstalled()) {\n      return <NoWalletDetected />;\n    }\n\n    // The next thing we need to do, is to ask the user to connect their wallet.\n    // When the wallet gets connected, we are going to save the users's address\n    // in the component's state. So, if it hasn't been saved yet, we have\n    // to show the ConnectWallet component.\n    //\n    // Note that we pass it a callback that is going to be called when the user\n    // clicks a button. This callback just calls the _connectWallet method.\n    if (!this.state.selectedAddress) {\n      return (\n        <ConnectWallet\n          connectWallet={() => this._connectWallet()}\n          networkError={this.state.networkError}\n          dismiss={() => this._dismissNetworkError()}\n        />\n      );\n    }\n\n    // If everything is loaded, we render the application.\n    return (\n      <div className=\"container p-4\">\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <p>\n              Welcome <b>{this.state.selectedAddress}</b>, you have{\" \"}\n              <b>\n                {this.state.balance.toString()}\n              </b>\n              .\n            </p>\n          </div>\n        </div>\n\n        <hr />\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/* \n              Sending a transaction isn't an immidiate action. You have to wait\n              for it to be mined.\n              If we are waiting for one, we show a message here.\n            */}\n            {this.state.txBeingSent && (\n              <WaitingForTransactionMessage txHash={this.state.txBeingSent} />\n            )}\n\n            {/* \n              Sending a transaction can fail in multiple ways. \n              If that happened, we show a message here.\n            */}\n            {this.state.transactionError && (\n              <TransactionErrorMessage\n                message={this._getRpcErrorMessage(this.state.transactionError)}\n                dismiss={() => this._dismissTransactionError()}\n              />\n            )}\n          </div>\n        </div>\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n\n            {/*\n              This component displays a form that the user can use to send a \n              transaction and transfer some tokens.\n              The component doesn't have logic, it just calls the transferTokens\n              callback.\n            */}\n            {(\n              <ApproveForAll\n                approveCaretaker={(caretaker, tokens) =>\n                  this._approveCaretaker(caretaker, tokens)\n                }\n                doDaily={(tokens) => this._doDaily(tokens)\n                }\n                tokenIds={this.state.summoners}\n                address={this.state.caretaker_address}\n              />\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  isMetaMaskInstalled() {\n    const { ethereum } = window\n    return Boolean(ethereum && ethereum.isMetaMask)\n  }\n\n  componentWillUnmount() {\n    // We poll the user's balance, so we have to stop doing that when Dapp\n    // gets unmounted\n    this._stopPollingData();\n  }\n\n  async _connectWallet() {\n    // This method is run when the user clicks the Connect. It connects the\n    // dapp to the user's wallet, and initializes it.\n    // To connect to the user's wallet, we have to run this method.\n    // It returns a promise that will resolve to the user's address.\n    try {\n      const [selectedAddress] = await window.ethereum.request({\n        method: 'eth_requestAccounts',\n      });\n      // First we check the network\n      if (!this._checkNetwork()) {\n        return;\n      }\n\n      // Once we have the address, we can initialize the application.\n      this._initialize(selectedAddress);\n    } catch (error) {\n      console.error(error)\n    }\n\n    // We reinitialize it whenever the user changes their account.\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      this._stopPollingData();\n      // `accountsChanged` event can be triggered with an undefined newAddress.\n      // This happens when the user removes the Dapp from the \"Connected\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n      // To avoid errors, we reset the dapp state \n      if (newAddress === undefined) {\n        return this._resetState();\n      }\n\n      this._initialize(newAddress);\n    });\n\n    // We reset the dapp state if the network is changed\n    window.ethereum.on(\"networkChanged\", ([networkId]) => {\n      this._stopPollingData();\n      this._resetState();\n    });\n  }\n\n  _initialize(userAddress) {\n    // This method initializes the dapp\n    // We first store the user's address in the component's state\n    this.setState({\n      selectedAddress: userAddress\n    });\n\n    this._initializeEthers();\n    this._getSummoners();\n    this._startPollingData();\n  }\n\n  // TODO : Repurpose to interact with caretaker contract\n  async _initializeEthers() {\n    // We first initialize ethers by creating a provider using window.ethereum\n    this._provider = new ethers.providers.Web3Provider(window.ethereum);\n    console.log(this._provider);\n\n\n    this._rarity = new ethers.Contract(\n      this.state.rarity_address,\n      Rarity.abi,\n      this._provider.getSigner(0)\n    );\n\n    this._caretaker = new ethers.Contract(\n      this.state.caretaker_address,\n      Caretaker.abi,\n      this._provider.getSigner(0)\n    );\n\n    console.log(\"initialized ethers caretaker contract at\", this._rarity.address);\n  }\n\n  // The next two methods are needed to start and stop polling data. While\n  // the data being polled here is specific to this example, you can use this\n  // pattern to read any data from your contracts.\n  //\n  // Note that if you don't need it to update in near real time, you probably\n  // don't need to poll it. If that's the case, you can just fetch it when you\n  // initialize the app, as we do with the token data.\n  _startPollingData() {\n    this._pollDataInterval = setInterval(() => this._getBalance(), 3000);\n\n    // We run it once immediately so we don't have to wait for it\n    this._getBalance();\n  }\n\n  _stopPollingData() {\n    clearInterval(this._pollDataInterval);\n    this._pollDataInterval = undefined;\n  }\n\n  // The next two methods just read from the contract and store the results\n  // in the component state.\n\n  async _getSummoners() {\n    // https://api.ftmscan.com/api?module=account&action=tokennfts&contractaddress=<rarityaddress>&address=ADDRESS&tag=latest&apikey=APIkey\n    const address = this.state.selectedAddress;\n    const contract = this.state.rarity_address;\n    const apikey = this.state.FTMSCAN_API_KEY;\n    console.log(address, contract, apikey);\n\n    let response;\n    if (apikey !== undefined) {\n      response = await axios({\n        method: 'get',\n        url: `${FTMSCAN_API}?module=account&action=tokennfttx&contractaddress=${contract}&address=${address}&tag=latest&apikey=${apikey}`,\n      });\n    } else {\n      console.log(\"Rate limited scan\");\n      response = await axios({\n        method: 'get',\n        url: `${FTMSCAN_API}?module=account&action=tokennfttx&contractaddress=${contract}&address=${address}&tag=latest`,\n      });\n    }\n\n    let summoners;\n    if (response.data.message.startsWith('OK')) {\n      summoners = response.data.result.map(a => a.tokenID);\n      console.log(summoners);\n    } else {\n      summoners = [];\n    }\n    this.setState({ summoners });\n  }\n\n  async _getBalance() {\n    try {\n      const balance = ethers.utils.formatEther(await this._provider.getBalance(this.state.selectedAddress));\n      console.log(\"Balance\", balance);\n\n      this.setState({ balance: balance });\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  async _approval(id, addr) {\n    try {\n      const approved = await this._rarity.getApproved(id);\n      console.log(\"Approved\", id, approved);\n\n      if (approved !== addr) {\n        const txn = await this._rarity.approve(addr, id);\n        this.setState({ txBeingSent: txn.hash });\n        const receipt = txn.wait();\n        // The receipt, contains a status flag, which is 0 to indicate an error.\n        if (receipt.status === 0) {\n          // We can't know the exact error that made the transaction fail when it\n          // was mined, so we throw this generic one.\n          throw new Error(\"Transaction failed\");\n        }\n        const approved = await this._rarity.getApproved(id);\n        console.log(\"Approved\", id, approved);\n      }\n    } catch (error) {\n      // We check the error code to see if this error was produced because the\n      // user rejected a tx. If that's the case, we do nothing.\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n        return;\n      }\n      else if (error.message === 'Internal JSON-RPC error.') {\n        // Metamask glitches out too frequently. This reruns the command\n        await this._approval(id, addr);\n      }\n\n      // Other errors are logged and stored in the Dapp's state. This is used to\n      // show them to the user, and for debugging.\n      console.error(error);\n      this.setState({ transactionError: error });\n    } finally {\n      // If we leave the try/catch, we aren't sending a tx anymore, so we clear\n      // this part of the state.\n      this.setState({ txBeingSent: undefined });\n    }\n  }\n\n  async _get_ready_for_adventure(id) {\n    console.log(id);\n    const timenow = Math.floor(Date.now() / 1000);\n    try {\n      const approved = await this._rarity.getApproved(id);\n      if (approved === this._caretaker.address) {\n        const adventureLog = await this._rarity.adventurers_log(id);\n        if (adventureLog <= timenow) {\n          console.log(\"Adding to list\");\n          return id;\n        } else {\n          console.log(\"Already done for today\", id);\n          return -1;\n        }\n      } else {\n        console.log(\"Not approved\", id);\n        return -1;\n      }\n    } catch (error) {\n      // We check the error code to see if this error was produced because the\n      // user rejected a tx. If that's the case, we do nothing.\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n        return -1;\n      } else if (error.message === 'Internal JSON-RPC error.') {\n        // Metamask glitches out too frequently. This reruns the command\n        return this._get_ready_for_adventure(id);\n      }\n    }\n  }\n\n  async _doDaily(checked_tokens) {\n    const tokens = []\n    // First get eligible tokens\n    for (let i = 0; i < checked_tokens.length; i++) {\n      const val = await this._get_ready_for_adventure(checked_tokens[i]);\n      console.log(val);\n      if (val !== -1) {\n        tokens.push(val);\n      }\n\n    }\n    // Call doAll for eligible tokens\n    if (tokens.length > 0) {\n      try {\n        console.log(\"Approved and valid\", tokens);\n        const txn3 = await this._caretaker.doAll(tokens);\n        const receipt3 = await txn3.wait();\n        console.log(receipt3.events);\n      } catch (error) {\n        // We check the error code to see if this error was produced because the\n        // user rejected a tx. If that's the case, we do nothing.\n        if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n          return;\n        }\n        // Other errors are logged and stored in the Dapp's state. This is used to\n        // show them to the user, and for debugging.\n        console.error(error);\n        this.setState({ transactionError: error });\n      } finally {\n        // If we leave the try/catch, we aren't sending a tx anymore, so we clear\n        // this part of the state.\n        this.setState({ txBeingSent: undefined });\n      }\n    }\n\n  }\n\n\n  // This method sends an ethereum transaction to transfer tokens.\n  // While this action is specific to this application, it illustrates how to\n  // send a transaction.\n  async _approveCaretaker(addr, tokens) {\n    // Sending a transaction is a complex operation:\n    //   - The user can reject it\n    //   - It can fail before reaching the ethereum network (i.e. if the user\n    //     doesn't have ETH for paying for the tx's gas)\n    //   - It has to be mined, so it isn't immediately confirmed.\n    //     Note that some testing networks, like Hardhat Network, do mine\n    //     transactions immediately, but your dapp should be prepared for\n    //     other networks.\n    //   - It can fail once mined.\n    //\n    // This method handles all of those things, so keep reading to learn how to\n    // do it.\n    console.log(\"Approving Caretaker at\", addr);\n    // When, we initialize the contract using that provider and the token's\n    // artifact. You can do this same thing with your contracts.\n\n    // If a transaction fails, we save that error in the component's state.\n    // We only save one such error, so before sending a second transaction, we\n    // clear it.\n    this._dismissTransactionError();\n\n    // We send the transaction, and save its hash in the Dapp's state. This\n    // way we can indicate that we are waiting for it to be mined.\n    console.log(Object.keys(tokens[0]));\n    for (let i = 0; i < tokens.length; i++) {\n      await this._approval(tokens[i], addr);\n    }\n    // If we got here, the transaction was successful, so you may want to\n    // update your state. Here, we update the user's balance.\n    await this._getBalance();\n  }\n\n  // This method just clears part of the state.\n  _dismissTransactionError() {\n    this.setState({ transactionError: undefined });\n  }\n\n  // This method just clears part of the state.\n  _dismissNetworkError() {\n    this.setState({ networkError: undefined });\n  }\n\n  // This is an utility method that turns an RPC error into a human readable\n  // message.\n  _getRpcErrorMessage(error) {\n    if (error.data) {\n      return error.data.message;\n    }\n\n    return error.message;\n  }\n\n  // This method resets the state\n  _resetState() {\n    this.setState(this.initialState);\n  }\n\n  // This method checks if Metamask selected network is Localhost:8545 \n  _checkNetwork() {\n    console.log(window.ethereum.networkVersion)\n    // 250 : Fantom Chain id\n    if (window.ethereum.networkVersion === `250`) {\n      return true;\n    }\n\n    this.setState({\n      networkError: 'Please connect Metamask to correct chain'\n    });\n\n    return false;\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Dapp } from \"./components/Dapp\";\n\n// We import bootstrap here, but you can remove if you want\nimport \"bootstrap/dist/css/bootstrap.css\";\n\n// This is the entry point of your application, but it just renders the Dapp\n// react component. All of the logic is contained in it.\n\nReactDOM.render(\n  <React.StrictMode>\n    <Dapp />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}